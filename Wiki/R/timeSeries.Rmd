---
  title: "Time series"
---
  

## Time Series

http://www.statmethods.net/advstats/timeseries.html

http://a-little-book-of-r-for-time-series.readthedocs.org/en/latest/src/timeseries.html#arima-models

```r
ts1 <- ts(c(2,3,2,3,4,5))

ts1 <- ts(1:10, frequency=4, start=c(1959, 2)) # 2nd Quarter of 1959

frequency(t1) # get frequency
frequency(t1) <- 2 # assign frequency

# extract data 
window(t2, start=as.Date('2000-01-01'), end=as.Date('2000-31-12') )
```
 * xts and zoo objects

```r
# ------------- xts or zoo for data with time stamp

# xts object is a subclass of zoo, which means zoo methods are called if an xts method doesn't exist for a generic function (e.g. $.zoo and $<-.zoo). Both zoo and xts objects are a matrix with an ordered index attribute. xts requires that the index be time-based.

prices <- c(1.1, 2.2, 3.3)
timestamps <-  c('2011-01-05 11:00', '2011-01-05 12:00', '2011-01-05 13:00')
stockprices <- data.frame(prices, timestamps)

# convert data.frame to time series
stockprices
# prices(numeric)    timestamps(character)
# 1.1         2011-01-05 11:00
# 2.2         2011-01-05 12:00
# 3.3         2011-01-05 13:00

require(xts)
stockpricesXts <- xts(stockprices$prices, order.by=as.POSIXct(stockprices$timestamps))
stockpricesXts

# select a time range
t1 <- stockpricesXts["2011-01-04T05:00/2011-01-05"]

# read time stamp with format
timestamps <-  strptime(timestamps, format="%d/%m/%Y %H:%M")


```

Deal with inregular time series

```r
# get minimum at an hour granularity
tMinHour <- trunc(min(time(ts)), units ='hour')
# back off 30 minute of the current hour
tMin <- tMinHour - (30 * 60)
# get max 
tMax <- max(time(ts)) + (30 * 60)
# create sequence for 'cut'
cSeq <- seq(tMin, tMax, by = '60 min')
# converted to a factor by cutting, cCut is a factor
cCut <- cut(time(ts), cSeq)
 # compute means , x is a array
newValue <- tapply(ts, cCut, mean) 

newTs <- xts(newValue, order.by=seq(tMinHour, tMax, by='60 min') )
plot(newTs)


# ------- fix NA value ------------

# assign 0 to NA
ts[is.na(ts)] <- 0 
# na.locf (Last Observation Carried Forward) from package zoo
ts <- na.locf(ts) 


```

## Moving Averages 

  * TTR

http://rss.acs.unt.edu/Rdoc/library/TTR/html/MovingAverages.html


## Arima 

  * forecast

```r
fit <- Arima(WWWusage, order=c(3,1,0))

# plot the model against the data
plot(fit$x,col="black")
lines(fitted(fit),col="red")

# auto arima
require(forecast)
fit <- auto.arima(ts)
plot(forecast(fit, h=5)) # 5 stps ahead

# Model Diagnostics for a Fitted ARIMA Model 
# gof.lag = maximum lag used in ACF and Ljung-Box tests for the residuals
tsdiag(fit,gof=50,omit.initial=FALSE)

# the 5th value in 5 stps ahead
forecast(fit, h=5)$mean[5]

# extract the (p, d, q) ; more info for arima.string() function
order <- c(fit$arma[1], fit$arma[6], fit$arma[2])
# or
order <- arimaorder(fit)

```


## ACF

http://a-little-book-of-r-for-time-series.readthedocs.org/en/latest/src/timeseries.html


```{r}
kings <- c(60, 43, 67, 50, 56, 42, 50, 65, 68, 43, 65, 34, 47, 34, 49, 41, 13, 35, 53, 56, 16, 43, 69, 59, 48, 59, 86, 55, 68, 51, 33, 49, 67, 77, 81, 67, 71, 81, 68, 70, 77, 56)
kingsts = ts(kings)
kingsts
acf(kingsts, lag.max = 20)


kings1diff = diff(kingsts, differences = 1)
acf(kings1diff, lag.max = 20)

```


## Decomposition

STL: Seasonal-Trend decomposition based on the Loess


```{r,warning=F}

sales<-c(39,  73,  41,  76,  75,  47,   4,  53,  40,  47,  31,  33,
         58,  85,  61,  98,  90,  59,  34,  74,  78,  74,  56,  55,
         91, 125,  96, 135, 131, 103,  86, 116, 117, 128, 113, 123)

time.series <- ts(data=sales, frequency = 12, start=c(2000, 1), end=c(2002, 12))
plot(time.series, xlab="Time", ylab="Sales (USD)")

decomposed <- stl(time.series, s.window="periodic")


# origional_value - seasonal = trend + remainder

seasonal <- decomposed$time.series[,"seasonal"]   # or decomposed$time.series[,1]
trend <- decomposed$time.series[,"trend"]         # or decomposed$time.series[,2]
remainder <- decomposed$time.series[,"remainder"] # or decomposed$time.series[,3]

plot(decomposed)



decomposed <- decompose(time.series)
plot(decomposed)

```


## Finding the period 

http://robjhyndman.com/hyndsight/tscharacteristics/

if you really have no idea what the periodicity is, probably the best approach is to find the frequency corresponding to the maximum of the spectral density.

```{r, warning=F}
find.freq <- function(x)
{
  n <- length(x)
  spec <- spec.ar(c(na.contiguous(x)),plot=FALSE)
  if(max(spec$spec)>10) # Arbitrary threshold chosen by trial and error.
  {
    period <- round(1/spec$freq[which.max(spec$spec)])
    if(period==Inf) # Find next local maximum
    {
      j <- which(diff(spec$spec)>0)
      if(length(j)>0)
      {
        nextmax <- j[1] + which.max(spec$spec[j[1]:500])
        if(nextmax <= length(spec$freq))
          period <- round(1/spec$freq[nextmax])
        else
          period <- 1
      }
      else
        period <- 1
    }
  }
  else
    period <- 1
  
  return(period)
}


temp <- sales
temp <- c(temp, temp)

freq <- print (find.freq(temp))


spec <- spec.ar(c(na.contiguous(temp)),plot=T)

decomposed  <- stl(ts(temp, frequency=freq), s.window="periodic")
plot(decomposed)


```

## ARIMA

ARIMA book: https://www.otexts.org/fpp

 * Generally, seasonal versions of ARIMA and ETS models are designed for shorter periods such as 12 for monthly data or 4 for quarterly data.


comparing results of applying transformation and seasonal configuration in arima

```{r, warning=F}

require(fpp) # for a10 dataset

a10train <- window(a10, end=2004.99)

par(mfrow=c(5,1),
    mar=c(2,2,2,2), oma=c(0,0,0,0)
)

plot(a10train)

lam <- BoxCox.lambda(a10train) # BoxCox transformation

# ------ auto.arima only
fit <- auto.arima(a10train)
fcast <- forecast(fit, h=50)
plot(fcast)
lines(a10, col="black")


# ------ auto.arima + transformation
fit2 <- auto.arima(a10train, lambda=lam)
fcast2 <- forecast(fit2, h=50)
plot(fcast2)
lines(a10, col="black")

# ------ Arima + transformation + order + seasonal 
order <- c(fit$arma[1], fit$arma[6], fit$arma[2])
seasonal=list(order=c(fit$arma[3], fit$arma[7], fit$arma[4]), period=fit$arma[5])
fit3 <- Arima(a10train, lambda=lam, order=order, seasonal=seasonal)
fcast3 <- forecast(fit3, h=50)
plot(fcast3)
lines(a10, col="black")

# ------ Arima + order 
order <- c(fit$arma[1], fit$arma[6], fit$arma[2])
fit4 <- Arima(a10train, order=order)
fcast4 <- forecast(fit4, h=50)
plot(fcast4)
lines(a10, col="black")


accuracy(fcast, a10)
accuracy(fcast2, a10)
accuracy(fcast3, a10)
accuracy(fcast4, a10)


```

## xreg/covariates object

```r
#
hour <- as.POSIXlt(time(xts1))$hour    # extract the hour of time stamp
xreg <- model.matrix(~as.factor(hour)) # hourly 


week <- as.POSIXlt(time(xts1))$wday    # find the day of the week
xreg <- model.matrix(~as.factor(week)) # week and weekend days

# Remove intercept
xreg <- xreg[,-1]

# Rename columns
# colnames(xreg) <- c("Mon","Tue","Wed","Thu","Fri","Sat")

fit2 <- auto.arima(... , xreg=xreg)
```

```r

tdata <- s

tdata <- ts(tdata)

fit1 <- auto.arima(tdata)
fit1

system.time(fit <- Arima(tdata, model=fit1 ))
fcast <- forecast(fit, h=5)
plot(fcast,include=50)
lines(tdata, col="red")
accuracy(fcast,tdata)


order <- c(fit1$arma[1], fit1$arma[6], fit1$arma[2])
system.time(fit <- arima(tdata, order=order) )
fcast <- forecast(fit, h=5)
plot(fcast,include=50)
lines(tdata, col="red")


accuracy(fcast,tdata)

```

